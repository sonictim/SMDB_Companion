import "./chunk-2Z2XDZGU.js";
import {
  SvelteComponentDev,
  add_iframe_resize_listener,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  binding_callbacks,
  check_outros,
  children,
  claim_element,
  claim_space,
  claim_text,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  onMount,
  outro_and_destroy_block,
  safe_not_equal,
  set_custom_element_data,
  set_style,
  space,
  text,
  tick,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots
} from "./chunk-TD4GBMNX.js";
import "./chunk-SSYGV25P.js";

// node_modules/.pnpm/svelte-virtual-list@3.0.1/node_modules/svelte-virtual-list/VirtualList.svelte
var file = "node_modules/.pnpm/svelte-virtual-list@3.0.1/node_modules/svelte-virtual-list/VirtualList.svelte";
function add_css(target) {
  append_styles(target, "svelte-1tqh76q", "svelte-virtual-list-viewport.svelte-1tqh76q{position:relative;overflow-y:auto;-webkit-overflow-scrolling:touch;display:block}svelte-virtual-list-contents.svelte-1tqh76q,svelte-virtual-list-row.svelte-1tqh76q{display:block}svelte-virtual-list-row.svelte-1tqh76q{overflow:hidden}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlydHVhbExpc3Quc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWdKQywyQ0FBNkIsQ0FDNUIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsVUFBVSxDQUFFLElBQUksQ0FDaEIsMkJBQTJCLEtBQUssQ0FDaEMsT0FBTyxDQUFFLEtBQ1YsQ0FFQSwyQ0FBNEIsQ0FBRSxzQ0FBd0IsQ0FDckQsT0FBTyxDQUFFLEtBQ1YsQ0FFQSxzQ0FBd0IsQ0FDdkIsUUFBUSxDQUFFLE1BQ1giLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVmlydHVhbExpc3Quc3ZlbHRlIl19 */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
var get_default_slot_changes = (dirty) => ({ item: dirty & /*visible*/
16 });
var get_default_slot_context = (ctx) => ({ item: (
  /*row*/
  ctx[23].data
) });
function fallback_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Missing template");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Missing template");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(173:26) Missing template",
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let svelte_virtual_list_row;
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      svelte_virtual_list_row = element("svelte-virtual-list-row");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      svelte_virtual_list_row = claim_element(nodes, "SVELTE-VIRTUAL-LIST-ROW", { class: true });
      var svelte_virtual_list_row_nodes = children(svelte_virtual_list_row);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(svelte_virtual_list_row_nodes);
      t = claim_space(svelte_virtual_list_row_nodes);
      svelte_virtual_list_row_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_custom_element_data(svelte_virtual_list_row, "class", "svelte-1tqh76q");
      add_location(svelte_virtual_list_row, file, 171, 3, 3683);
      this.first = svelte_virtual_list_row;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_virtual_list_row, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(svelte_virtual_list_row, null);
      }
      append_hydration_dev(svelte_virtual_list_row, t);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, visible*/
        8208)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[13],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_virtual_list_row);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(171:2) {#each visible as row (row.index)}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let svelte_virtual_list_viewport;
  let svelte_virtual_list_contents;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let svelte_virtual_list_viewport_resize_listener;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*visible*/
    ctx[4]
  );
  validate_each_argument(each_value);
  const get_key = (ctx2) => (
    /*row*/
    ctx2[23].index
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
      svelte_virtual_list_contents = element("svelte-virtual-list-contents");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      svelte_virtual_list_viewport = claim_element(nodes, "SVELTE-VIRTUAL-LIST-VIEWPORT", { style: true, class: true });
      var svelte_virtual_list_viewport_nodes = children(svelte_virtual_list_viewport);
      svelte_virtual_list_contents = claim_element(svelte_virtual_list_viewport_nodes, "SVELTE-VIRTUAL-LIST-CONTENTS", { style: true, class: true });
      var svelte_virtual_list_contents_nodes = children(svelte_virtual_list_contents);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(svelte_virtual_list_contents_nodes);
      }
      svelte_virtual_list_contents_nodes.forEach(detach_dev);
      svelte_virtual_list_viewport_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(
        svelte_virtual_list_contents,
        "padding-top",
        /*top*/
        ctx[5] + "px"
      );
      set_style(
        svelte_virtual_list_contents,
        "padding-bottom",
        /*bottom*/
        ctx[6] + "px"
      );
      set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-1tqh76q");
      add_location(svelte_virtual_list_contents, file, 166, 1, 3527);
      set_style(
        svelte_virtual_list_viewport,
        "height",
        /*height*/
        ctx[0]
      );
      set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-1tqh76q");
      add_render_callback(() => (
        /*svelte_virtual_list_viewport_elementresize_handler*/
        ctx[17].call(svelte_virtual_list_viewport)
      ));
      add_location(svelte_virtual_list_viewport, file, 160, 0, 3381);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_virtual_list_viewport, anchor);
      append_hydration_dev(svelte_virtual_list_viewport, svelte_virtual_list_contents);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(svelte_virtual_list_contents, null);
        }
      }
      ctx[15](svelte_virtual_list_contents);
      ctx[16](svelte_virtual_list_viewport);
      svelte_virtual_list_viewport_resize_listener = add_iframe_resize_listener(
        svelte_virtual_list_viewport,
        /*svelte_virtual_list_viewport_elementresize_handler*/
        ctx[17].bind(svelte_virtual_list_viewport)
      );
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          svelte_virtual_list_viewport,
          "scroll",
          /*handle_scroll*/
          ctx[7],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$$scope, visible*/
      8208) {
        each_value = /*visible*/
        ctx2[4];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
      if (!current || dirty & /*top*/
      32) {
        set_style(
          svelte_virtual_list_contents,
          "padding-top",
          /*top*/
          ctx2[5] + "px"
        );
      }
      if (!current || dirty & /*bottom*/
      64) {
        set_style(
          svelte_virtual_list_contents,
          "padding-bottom",
          /*bottom*/
          ctx2[6] + "px"
        );
      }
      if (!current || dirty & /*height*/
      1) {
        set_style(
          svelte_virtual_list_viewport,
          "height",
          /*height*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_virtual_list_viewport);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[15](null);
      ctx[16](null);
      svelte_virtual_list_viewport_resize_listener();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var refreshAction;
function notifyRefresh() {
  refreshAction();
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VirtualList", slots, ["default"]);
  let { items } = $$props;
  let { height = "100%" } = $$props;
  let { itemHeight = void 0 } = $$props;
  let foo;
  let { start = 0 } = $$props;
  let { end = 0 } = $$props;
  let height_map = [];
  let rows;
  let viewport;
  let contents;
  let viewport_height = 0;
  let visible;
  let mounted;
  let top = 0;
  let bottom = 0;
  let average_height;
  async function refresh(items2, viewport_height2, itemHeight2) {
    const { scrollTop } = viewport;
    await tick();
    let content_height = top - scrollTop;
    let i = start;
    while (content_height < viewport_height2 && i < items2.length) {
      let row = rows[i - start];
      if (!row) {
        $$invalidate(9, end = i + 1);
        await tick();
        row = rows[i - start];
      }
      const row_height = height_map[i] = itemHeight2 || row.offsetHeight;
      content_height += row_height;
      i += 1;
    }
    $$invalidate(9, end = i);
    const remaining = items2.length - end;
    average_height = (top + content_height) / end;
    $$invalidate(6, bottom = remaining * average_height);
    height_map.length = items2.length;
  }
  async function handle_scroll() {
    const { scrollTop } = viewport;
    const old_start = start;
    for (let v = 0; v < rows.length; v += 1) {
      height_map[start + v] = itemHeight || rows[v].offsetHeight;
    }
    let i = 0;
    let y = 0;
    while (i < items.length) {
      const row_height = height_map[i] || average_height;
      if (y + row_height > scrollTop) {
        $$invalidate(8, start = i);
        $$invalidate(5, top = y);
        break;
      }
      y += row_height;
      i += 1;
    }
    while (i < items.length) {
      y += height_map[i] || average_height;
      i += 1;
      if (y > scrollTop + viewport_height)
        break;
    }
    $$invalidate(9, end = i);
    const remaining = items.length - end;
    average_height = y / end;
    while (i < items.length)
      height_map[i++] = average_height;
    $$invalidate(6, bottom = remaining * average_height);
    if (start < old_start) {
      await tick();
      let expected_height = 0;
      let actual_height = 0;
      for (let i2 = start; i2 < old_start; i2 += 1) {
        if (rows[i2 - start]) {
          expected_height += height_map[i2];
          actual_height += itemHeight || rows[i2 - start].offsetHeight;
        }
      }
      const d = actual_height - expected_height;
      viewport.scrollTo(0, scrollTop + d);
    }
  }
  refreshAction = () => refresh(items, viewport_height, itemHeight);
  onMount(() => {
    rows = contents.getElementsByTagName("svelte-virtual-list-row");
    $$invalidate(12, mounted = true);
  });
  $$self.$$.on_mount.push(function() {
    if (items === void 0 && !("items" in $$props || $$self.$$.bound[$$self.$$.props["items"]])) {
      console.warn("<VirtualList> was created without expected prop 'items'");
    }
  });
  const writable_props = ["items", "height", "itemHeight", "start", "end"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VirtualList> was created with unknown prop '${key}'`);
  });
  function svelte_virtual_list_contents_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contents = $$value;
      $$invalidate(3, contents);
    });
  }
  function svelte_virtual_list_viewport_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      viewport = $$value;
      $$invalidate(2, viewport);
    });
  }
  function svelte_virtual_list_viewport_elementresize_handler() {
    viewport_height = this.offsetHeight;
    $$invalidate(1, viewport_height);
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(10, items = $$props2.items);
    if ("height" in $$props2)
      $$invalidate(0, height = $$props2.height);
    if ("itemHeight" in $$props2)
      $$invalidate(11, itemHeight = $$props2.itemHeight);
    if ("start" in $$props2)
      $$invalidate(8, start = $$props2.start);
    if ("end" in $$props2)
      $$invalidate(9, end = $$props2.end);
    if ("$$scope" in $$props2)
      $$invalidate(13, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    refreshAction,
    notifyRefresh,
    onMount,
    tick,
    items,
    height,
    itemHeight,
    foo,
    start,
    end,
    height_map,
    rows,
    viewport,
    contents,
    viewport_height,
    visible,
    mounted,
    top,
    bottom,
    average_height,
    refresh,
    handle_scroll
  });
  $$self.$inject_state = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(10, items = $$props2.items);
    if ("height" in $$props2)
      $$invalidate(0, height = $$props2.height);
    if ("itemHeight" in $$props2)
      $$invalidate(11, itemHeight = $$props2.itemHeight);
    if ("foo" in $$props2)
      foo = $$props2.foo;
    if ("start" in $$props2)
      $$invalidate(8, start = $$props2.start);
    if ("end" in $$props2)
      $$invalidate(9, end = $$props2.end);
    if ("height_map" in $$props2)
      height_map = $$props2.height_map;
    if ("rows" in $$props2)
      rows = $$props2.rows;
    if ("viewport" in $$props2)
      $$invalidate(2, viewport = $$props2.viewport);
    if ("contents" in $$props2)
      $$invalidate(3, contents = $$props2.contents);
    if ("viewport_height" in $$props2)
      $$invalidate(1, viewport_height = $$props2.viewport_height);
    if ("visible" in $$props2)
      $$invalidate(4, visible = $$props2.visible);
    if ("mounted" in $$props2)
      $$invalidate(12, mounted = $$props2.mounted);
    if ("top" in $$props2)
      $$invalidate(5, top = $$props2.top);
    if ("bottom" in $$props2)
      $$invalidate(6, bottom = $$props2.bottom);
    if ("average_height" in $$props2)
      average_height = $$props2.average_height;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*items, start, end*/
    1792) {
      $:
        $$invalidate(4, visible = items.slice(start, end).map((data, i) => {
          return { index: i + start, data };
        }));
    }
    if ($$self.$$.dirty & /*mounted, items, viewport_height, itemHeight*/
    7170) {
      $:
        if (mounted)
          refresh(items, viewport_height, itemHeight);
    }
  };
  return [
    height,
    viewport_height,
    viewport,
    contents,
    visible,
    top,
    bottom,
    handle_scroll,
    start,
    end,
    items,
    itemHeight,
    mounted,
    $$scope,
    slots,
    svelte_virtual_list_contents_binding,
    svelte_virtual_list_viewport_binding,
    svelte_virtual_list_viewport_elementresize_handler
  ];
}
var VirtualList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        items: 10,
        height: 0,
        itemHeight: 11,
        start: 8,
        end: 9
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VirtualList",
      options,
      id: create_fragment.name
    });
  }
  get items() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemHeight() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemHeight(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get start() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set start(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get end() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set end(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VirtualList_default = VirtualList;
export {
  VirtualList_default as default,
  notifyRefresh
};
//# sourceMappingURL=svelte-virtual-list.js.map
