{
  "version": 3,
  "sources": ["../../.pnpm/@tauri-apps+api@2.4.1/node_modules/@tauri-apps/api/dpi.js", "../../.pnpm/@tauri-apps+api@2.4.1/node_modules/@tauri-apps/api/image.js"],
  "sourcesContent": ["import { SERIALIZE_TO_IPC_FN } from './core.js';\n\n// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n/**\n * A size represented in logical pixels.\n *\n * @since 2.0.0\n */\nclass LogicalSize {\n    constructor(...args) {\n        this.type = 'Logical';\n        if (args.length === 1) {\n            if ('Logical' in args[0]) {\n                this.width = args[0].Logical.width;\n                this.height = args[0].Logical.height;\n            }\n            else {\n                this.width = args[0].width;\n                this.height = args[0].height;\n            }\n        }\n        else {\n            this.width = args[0];\n            this.height = args[1];\n        }\n    }\n    /**\n     * Converts the logical size to a physical one.\n     * @example\n     * ```typescript\n     * import { LogicalSize } from '@tauri-apps/api/dpi';\n     * import { getCurrentWindow } from '@tauri-apps/api/window';\n     *\n     * const appWindow = getCurrentWindow();\n     * const factor = await appWindow.scaleFactor();\n     * const size = new LogicalSize(400, 500);\n     * const physical = size.toPhysical(factor);\n     * ```\n     *\n     * @since 2.0.0\n     */\n    toPhysical(scaleFactor) {\n        return new PhysicalSize(this.width * scaleFactor, this.height * scaleFactor);\n    }\n    [SERIALIZE_TO_IPC_FN]() {\n        return {\n            width: this.width,\n            height: this.height\n        };\n    }\n    toJSON() {\n        // eslint-disable-next-line security/detect-object-injection\n        return this[SERIALIZE_TO_IPC_FN]();\n    }\n}\n/**\n * A size represented in physical pixels.\n *\n * @since 2.0.0\n */\nclass PhysicalSize {\n    constructor(...args) {\n        this.type = 'Physical';\n        if (args.length === 1) {\n            if ('Physical' in args[0]) {\n                this.width = args[0].Physical.width;\n                this.height = args[0].Physical.height;\n            }\n            else {\n                this.width = args[0].width;\n                this.height = args[0].height;\n            }\n        }\n        else {\n            this.width = args[0];\n            this.height = args[1];\n        }\n    }\n    /**\n     * Converts the physical size to a logical one.\n     * @example\n     * ```typescript\n     * import { getCurrentWindow } from '@tauri-apps/api/window';\n     * const appWindow = getCurrentWindow();\n     * const factor = await appWindow.scaleFactor();\n     * const size = await appWindow.innerSize(); // PhysicalSize\n     * const logical = size.toLogical(factor);\n     * ```\n     */\n    toLogical(scaleFactor) {\n        return new LogicalSize(this.width / scaleFactor, this.height / scaleFactor);\n    }\n    [SERIALIZE_TO_IPC_FN]() {\n        return {\n            width: this.width,\n            height: this.height\n        };\n    }\n    toJSON() {\n        // eslint-disable-next-line security/detect-object-injection\n        return this[SERIALIZE_TO_IPC_FN]();\n    }\n}\n/**\n * A size represented either in physical or in logical pixels.\n *\n * This type is basically a union type of {@linkcode LogicalSize} and {@linkcode PhysicalSize}\n * but comes in handy when using `tauri::Size` in Rust as an argument to a command, as this class\n * automatically serializes into a valid format so it can be deserialized correctly into `tauri::Size`\n *\n * So instead of\n * ```typescript\n * import { invoke } from '@tauri-apps/api/core';\n * import { LogicalSize, PhysicalSize } from '@tauri-apps/api/dpi';\n *\n * const size: LogicalSize | PhysicalSize = someFunction(); // where someFunction returns either LogicalSize or PhysicalSize\n * const validSize = size instanceof LogicalSize\n *   ? { Logical: { width: size.width, height: size.height } }\n *   : { Physical: { width: size.width, height: size.height } }\n * await invoke(\"do_something_with_size\", { size: validSize });\n * ```\n *\n * You can just use {@linkcode Size}\n * ```typescript\n * import { invoke } from '@tauri-apps/api/core';\n * import { LogicalSize, PhysicalSize, Size } from '@tauri-apps/api/dpi';\n *\n * const size: LogicalSize | PhysicalSize = someFunction(); // where someFunction returns either LogicalSize or PhysicalSize\n * const validSize = new Size(size);\n * await invoke(\"do_something_with_size\", { size: validSize });\n * ```\n *\n * @since 2.1.0\n */\nclass Size {\n    constructor(size) {\n        this.size = size;\n    }\n    toLogical(scaleFactor) {\n        return this.size instanceof LogicalSize\n            ? this.size\n            : this.size.toLogical(scaleFactor);\n    }\n    toPhysical(scaleFactor) {\n        return this.size instanceof PhysicalSize\n            ? this.size\n            : this.size.toPhysical(scaleFactor);\n    }\n    [SERIALIZE_TO_IPC_FN]() {\n        return {\n            [`${this.size.type}`]: {\n                width: this.size.width,\n                height: this.size.height\n            }\n        };\n    }\n    toJSON() {\n        // eslint-disable-next-line security/detect-object-injection\n        return this[SERIALIZE_TO_IPC_FN]();\n    }\n}\n/**\n *  A position represented in logical pixels.\n *\n * @since 2.0.0\n */\nclass LogicalPosition {\n    constructor(...args) {\n        this.type = 'Logical';\n        if (args.length === 1) {\n            if ('Logical' in args[0]) {\n                this.x = args[0].Logical.x;\n                this.y = args[0].Logical.y;\n            }\n            else {\n                this.x = args[0].x;\n                this.y = args[0].y;\n            }\n        }\n        else {\n            this.x = args[0];\n            this.y = args[1];\n        }\n    }\n    /**\n     * Converts the logical position to a physical one.\n     * @example\n     * ```typescript\n     * import { LogicalPosition } from '@tauri-apps/api/dpi';\n     * import { getCurrentWindow } from '@tauri-apps/api/window';\n     *\n     * const appWindow = getCurrentWindow();\n     * const factor = await appWindow.scaleFactor();\n     * const position = new LogicalPosition(400, 500);\n     * const physical = position.toPhysical(factor);\n     * ```\n     *\n     * @since 2.0.0\n     */\n    toPhysical(scaleFactor) {\n        return new PhysicalPosition(this.x * scaleFactor, this.y * scaleFactor);\n    }\n    [SERIALIZE_TO_IPC_FN]() {\n        return {\n            x: this.x,\n            y: this.y\n        };\n    }\n    toJSON() {\n        // eslint-disable-next-line security/detect-object-injection\n        return this[SERIALIZE_TO_IPC_FN]();\n    }\n}\n/**\n *  A position represented in physical pixels.\n *\n * @since 2.0.0\n */\nclass PhysicalPosition {\n    constructor(...args) {\n        this.type = 'Physical';\n        if (args.length === 1) {\n            if ('Physical' in args[0]) {\n                this.x = args[0].Physical.x;\n                this.y = args[0].Physical.y;\n            }\n            else {\n                this.x = args[0].x;\n                this.y = args[0].y;\n            }\n        }\n        else {\n            this.x = args[0];\n            this.y = args[1];\n        }\n    }\n    /**\n     * Converts the physical position to a logical one.\n     * @example\n     * ```typescript\n     * import { PhysicalPosition } from '@tauri-apps/api/dpi';\n     * import { getCurrentWindow } from '@tauri-apps/api/window';\n     *\n     * const appWindow = getCurrentWindow();\n     * const factor = await appWindow.scaleFactor();\n     * const position = new PhysicalPosition(400, 500);\n     * const physical = position.toLogical(factor);\n     * ```\n     *\n     * @since 2.0.0\n     */\n    toLogical(scaleFactor) {\n        return new LogicalPosition(this.x / scaleFactor, this.y / scaleFactor);\n    }\n    [SERIALIZE_TO_IPC_FN]() {\n        return {\n            x: this.x,\n            y: this.y\n        };\n    }\n    toJSON() {\n        // eslint-disable-next-line security/detect-object-injection\n        return this[SERIALIZE_TO_IPC_FN]();\n    }\n}\n/**\n * A position represented either in physical or in logical pixels.\n *\n * This type is basically a union type of {@linkcode LogicalSize} and {@linkcode PhysicalSize}\n * but comes in handy when using `tauri::Position` in Rust as an argument to a command, as this class\n * automatically serializes into a valid format so it can be deserialized correctly into `tauri::Position`\n *\n * So instead of\n * ```typescript\n * import { invoke } from '@tauri-apps/api/core';\n * import { LogicalPosition, PhysicalPosition } from '@tauri-apps/api/dpi';\n *\n * const position: LogicalPosition | PhysicalPosition = someFunction(); // where someFunction returns either LogicalPosition or PhysicalPosition\n * const validPosition = position instanceof LogicalPosition\n *   ? { Logical: { x: position.x, y: position.y } }\n *   : { Physical: { x: position.x, y: position.y } }\n * await invoke(\"do_something_with_position\", { position: validPosition });\n * ```\n *\n * You can just use {@linkcode Position}\n * ```typescript\n * import { invoke } from '@tauri-apps/api/core';\n * import { LogicalPosition, PhysicalPosition, Position } from '@tauri-apps/api/dpi';\n *\n * const position: LogicalPosition | PhysicalPosition = someFunction(); // where someFunction returns either LogicalPosition or PhysicalPosition\n * const validPosition = new Position(position);\n * await invoke(\"do_something_with_position\", { position: validPosition });\n * ```\n *\n * @since 2.1.0\n */\nclass Position {\n    constructor(position) {\n        this.position = position;\n    }\n    toLogical(scaleFactor) {\n        return this.position instanceof LogicalPosition\n            ? this.position\n            : this.position.toLogical(scaleFactor);\n    }\n    toPhysical(scaleFactor) {\n        return this.position instanceof PhysicalPosition\n            ? this.position\n            : this.position.toPhysical(scaleFactor);\n    }\n    [SERIALIZE_TO_IPC_FN]() {\n        return {\n            [`${this.position.type}`]: {\n                x: this.position.x,\n                y: this.position.y\n            }\n        };\n    }\n    toJSON() {\n        // eslint-disable-next-line security/detect-object-injection\n        return this[SERIALIZE_TO_IPC_FN]();\n    }\n}\n\nexport { LogicalPosition, LogicalSize, PhysicalPosition, PhysicalSize, Position, Size };\n", "import { Resource, invoke } from './core.js';\n\n// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n/** An RGBA Image in row-major order from top to bottom. */\nclass Image extends Resource {\n    /**\n     * Creates an Image from a resource ID. For internal use only.\n     *\n     * @ignore\n     */\n    constructor(rid) {\n        super(rid);\n    }\n    /** Creates a new Image using RGBA data, in row-major order from top to bottom, and with specified width and height. */\n    static async new(rgba, width, height) {\n        return invoke('plugin:image|new', {\n            rgba: transformImage(rgba),\n            width,\n            height\n        }).then((rid) => new Image(rid));\n    }\n    /**\n     * Creates a new image using the provided bytes by inferring the file format.\n     * If the format is known, prefer [@link Image.fromPngBytes] or [@link Image.fromIcoBytes].\n     *\n     * Only `ico` and `png` are supported (based on activated feature flag).\n     *\n     * Note that you need the `image-ico` or `image-png` Cargo features to use this API.\n     * To enable it, change your Cargo.toml file:\n     * ```toml\n     * [dependencies]\n     * tauri = { version = \"...\", features = [\"...\", \"image-png\"] }\n     * ```\n     */\n    static async fromBytes(bytes) {\n        return invoke('plugin:image|from_bytes', {\n            bytes: transformImage(bytes)\n        }).then((rid) => new Image(rid));\n    }\n    /**\n     * Creates a new image using the provided path.\n     *\n     * Only `ico` and `png` are supported (based on activated feature flag).\n     *\n     * Note that you need the `image-ico` or `image-png` Cargo features to use this API.\n     * To enable it, change your Cargo.toml file:\n     * ```toml\n     * [dependencies]\n     * tauri = { version = \"...\", features = [\"...\", \"image-png\"] }\n     * ```\n     */\n    static async fromPath(path) {\n        return invoke('plugin:image|from_path', { path }).then((rid) => new Image(rid));\n    }\n    /** Returns the RGBA data for this image, in row-major order from top to bottom.  */\n    async rgba() {\n        return invoke('plugin:image|rgba', {\n            rid: this.rid\n        }).then((buffer) => new Uint8Array(buffer));\n    }\n    /** Returns the size of this image.  */\n    async size() {\n        return invoke('plugin:image|size', { rid: this.rid });\n    }\n}\n/**\n * Transforms image from various types into a type acceptable by Rust.\n *\n * See [tauri::image::JsImage](https://docs.rs/tauri/2/tauri/image/enum.JsImage.html) for more information.\n * Note the API signature is not stable and might change.\n */\nfunction transformImage(image) {\n    const ret = image == null\n        ? null\n        : typeof image === 'string'\n            ? image\n            : image instanceof Image\n                ? image.rid\n                : image;\n    return ret;\n}\n\nexport { Image, transformImage };\n"],
  "mappings": "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",
  "names": []
}
